// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/events/cloud/iot/v1/data.proto

package google.events.cloud.iot.v1;

/**
 * <pre>
 * A container for a group of devices.
 * </pre>
 *
 * Protobuf type {@code google.events.cloud.iot.v1.DeviceRegistry}
 */
public  final class DeviceRegistry extends
    com.google.protobuf.GeneratedMessageLite<
        DeviceRegistry, DeviceRegistry.Builder> implements
    // @@protoc_insertion_point(message_implements:google.events.cloud.iot.v1.DeviceRegistry)
    DeviceRegistryOrBuilder {
  private DeviceRegistry() {
    id_ = "";
    name_ = "";
    eventNotificationConfigs_ = emptyProtobufList();
    credentials_ = emptyProtobufList();
  }
  public static final int ID_FIELD_NUMBER = 1;
  private java.lang.String id_;
  /**
   * <pre>
   * The identifier of this device registry. For example, `myRegistry`.
   * </pre>
   *
   * <code>string id = 1;</code>
   * @return The id.
   */
  @java.lang.Override
  public java.lang.String getId() {
    return id_;
  }
  /**
   * <pre>
   * The identifier of this device registry. For example, `myRegistry`.
   * </pre>
   *
   * <code>string id = 1;</code>
   * @return The bytes for id.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(id_);
  }
  /**
   * <pre>
   * The identifier of this device registry. For example, `myRegistry`.
   * </pre>
   *
   * <code>string id = 1;</code>
   * @param value The id to set.
   */
  private void setId(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    id_ = value;
  }
  /**
   * <pre>
   * The identifier of this device registry. For example, `myRegistry`.
   * </pre>
   *
   * <code>string id = 1;</code>
   */
  private void clearId() {
    
    id_ = getDefaultInstance().getId();
  }
  /**
   * <pre>
   * The identifier of this device registry. For example, `myRegistry`.
   * </pre>
   *
   * <code>string id = 1;</code>
   * @param value The bytes for id to set.
   */
  private void setIdBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    id_ = value.toStringUtf8();
    
  }

  public static final int NAME_FIELD_NUMBER = 2;
  private java.lang.String name_;
  /**
   * <pre>
   * The resource path name. For example,
   * `projects/example-project/locations/us-central1/registries/my-registry`.
   * </pre>
   *
   * <code>string name = 2;</code>
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    return name_;
  }
  /**
   * <pre>
   * The resource path name. For example,
   * `projects/example-project/locations/us-central1/registries/my-registry`.
   * </pre>
   *
   * <code>string name = 2;</code>
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(name_);
  }
  /**
   * <pre>
   * The resource path name. For example,
   * `projects/example-project/locations/us-central1/registries/my-registry`.
   * </pre>
   *
   * <code>string name = 2;</code>
   * @param value The name to set.
   */
  private void setName(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    name_ = value;
  }
  /**
   * <pre>
   * The resource path name. For example,
   * `projects/example-project/locations/us-central1/registries/my-registry`.
   * </pre>
   *
   * <code>string name = 2;</code>
   */
  private void clearName() {
    
    name_ = getDefaultInstance().getName();
  }
  /**
   * <pre>
   * The resource path name. For example,
   * `projects/example-project/locations/us-central1/registries/my-registry`.
   * </pre>
   *
   * <code>string name = 2;</code>
   * @param value The bytes for name to set.
   */
  private void setNameBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    name_ = value.toStringUtf8();
    
  }

  public static final int EVENT_NOTIFICATION_CONFIGS_FIELD_NUMBER = 10;
  private com.google.protobuf.Internal.ProtobufList<google.events.cloud.iot.v1.EventNotificationConfig> eventNotificationConfigs_;
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  @java.lang.Override
  public java.util.List<google.events.cloud.iot.v1.EventNotificationConfig> getEventNotificationConfigsList() {
    return eventNotificationConfigs_;
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  public java.util.List<? extends google.events.cloud.iot.v1.EventNotificationConfigOrBuilder> 
      getEventNotificationConfigsOrBuilderList() {
    return eventNotificationConfigs_;
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  @java.lang.Override
  public int getEventNotificationConfigsCount() {
    return eventNotificationConfigs_.size();
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  @java.lang.Override
  public google.events.cloud.iot.v1.EventNotificationConfig getEventNotificationConfigs(int index) {
    return eventNotificationConfigs_.get(index);
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  public google.events.cloud.iot.v1.EventNotificationConfigOrBuilder getEventNotificationConfigsOrBuilder(
      int index) {
    return eventNotificationConfigs_.get(index);
  }
  private void ensureEventNotificationConfigsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<google.events.cloud.iot.v1.EventNotificationConfig> tmp = eventNotificationConfigs_;
    if (!tmp.isModifiable()) {
      eventNotificationConfigs_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  private void setEventNotificationConfigs(
      int index, google.events.cloud.iot.v1.EventNotificationConfig value) {
    value.getClass();
  ensureEventNotificationConfigsIsMutable();
    eventNotificationConfigs_.set(index, value);
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  private void addEventNotificationConfigs(google.events.cloud.iot.v1.EventNotificationConfig value) {
    value.getClass();
  ensureEventNotificationConfigsIsMutable();
    eventNotificationConfigs_.add(value);
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  private void addEventNotificationConfigs(
      int index, google.events.cloud.iot.v1.EventNotificationConfig value) {
    value.getClass();
  ensureEventNotificationConfigsIsMutable();
    eventNotificationConfigs_.add(index, value);
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  private void addAllEventNotificationConfigs(
      java.lang.Iterable<? extends google.events.cloud.iot.v1.EventNotificationConfig> values) {
    ensureEventNotificationConfigsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, eventNotificationConfigs_);
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  private void clearEventNotificationConfigs() {
    eventNotificationConfigs_ = emptyProtobufList();
  }
  /**
   * <pre>
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
   */
  private void removeEventNotificationConfigs(int index) {
    ensureEventNotificationConfigsIsMutable();
    eventNotificationConfigs_.remove(index);
  }

  public static final int STATE_NOTIFICATION_CONFIG_FIELD_NUMBER = 7;
  private google.events.cloud.iot.v1.StateNotificationConfig stateNotificationConfig_;
  /**
   * <pre>
   * The configuration for notification of new states received from the device.
   * State updates are guaranteed to be stored in the state history, but
   * notifications to Cloud Pub/Sub are not guaranteed. For example, if
   * permissions are misconfigured or the specified topic doesn't exist, no
   * notification will be published but the state will still be stored in Cloud
   * IoT Core.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
   */
  @java.lang.Override
  public boolean hasStateNotificationConfig() {
    return stateNotificationConfig_ != null;
  }
  /**
   * <pre>
   * The configuration for notification of new states received from the device.
   * State updates are guaranteed to be stored in the state history, but
   * notifications to Cloud Pub/Sub are not guaranteed. For example, if
   * permissions are misconfigured or the specified topic doesn't exist, no
   * notification will be published but the state will still be stored in Cloud
   * IoT Core.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
   */
  @java.lang.Override
  public google.events.cloud.iot.v1.StateNotificationConfig getStateNotificationConfig() {
    return stateNotificationConfig_ == null ? google.events.cloud.iot.v1.StateNotificationConfig.getDefaultInstance() : stateNotificationConfig_;
  }
  /**
   * <pre>
   * The configuration for notification of new states received from the device.
   * State updates are guaranteed to be stored in the state history, but
   * notifications to Cloud Pub/Sub are not guaranteed. For example, if
   * permissions are misconfigured or the specified topic doesn't exist, no
   * notification will be published but the state will still be stored in Cloud
   * IoT Core.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
   */
  private void setStateNotificationConfig(google.events.cloud.iot.v1.StateNotificationConfig value) {
    value.getClass();
  stateNotificationConfig_ = value;
    
    }
  /**
   * <pre>
   * The configuration for notification of new states received from the device.
   * State updates are guaranteed to be stored in the state history, but
   * notifications to Cloud Pub/Sub are not guaranteed. For example, if
   * permissions are misconfigured or the specified topic doesn't exist, no
   * notification will be published but the state will still be stored in Cloud
   * IoT Core.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeStateNotificationConfig(google.events.cloud.iot.v1.StateNotificationConfig value) {
    value.getClass();
  if (stateNotificationConfig_ != null &&
        stateNotificationConfig_ != google.events.cloud.iot.v1.StateNotificationConfig.getDefaultInstance()) {
      stateNotificationConfig_ =
        google.events.cloud.iot.v1.StateNotificationConfig.newBuilder(stateNotificationConfig_).mergeFrom(value).buildPartial();
    } else {
      stateNotificationConfig_ = value;
    }
    
  }
  /**
   * <pre>
   * The configuration for notification of new states received from the device.
   * State updates are guaranteed to be stored in the state history, but
   * notifications to Cloud Pub/Sub are not guaranteed. For example, if
   * permissions are misconfigured or the specified topic doesn't exist, no
   * notification will be published but the state will still be stored in Cloud
   * IoT Core.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
   */
  private void clearStateNotificationConfig() {  stateNotificationConfig_ = null;
    
  }

  public static final int MQTT_CONFIG_FIELD_NUMBER = 4;
  private google.events.cloud.iot.v1.MqttConfig mqttConfig_;
  /**
   * <pre>
   * The MQTT configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
   */
  @java.lang.Override
  public boolean hasMqttConfig() {
    return mqttConfig_ != null;
  }
  /**
   * <pre>
   * The MQTT configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
   */
  @java.lang.Override
  public google.events.cloud.iot.v1.MqttConfig getMqttConfig() {
    return mqttConfig_ == null ? google.events.cloud.iot.v1.MqttConfig.getDefaultInstance() : mqttConfig_;
  }
  /**
   * <pre>
   * The MQTT configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
   */
  private void setMqttConfig(google.events.cloud.iot.v1.MqttConfig value) {
    value.getClass();
  mqttConfig_ = value;
    
    }
  /**
   * <pre>
   * The MQTT configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeMqttConfig(google.events.cloud.iot.v1.MqttConfig value) {
    value.getClass();
  if (mqttConfig_ != null &&
        mqttConfig_ != google.events.cloud.iot.v1.MqttConfig.getDefaultInstance()) {
      mqttConfig_ =
        google.events.cloud.iot.v1.MqttConfig.newBuilder(mqttConfig_).mergeFrom(value).buildPartial();
    } else {
      mqttConfig_ = value;
    }
    
  }
  /**
   * <pre>
   * The MQTT configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
   */
  private void clearMqttConfig() {  mqttConfig_ = null;
    
  }

  public static final int HTTP_CONFIG_FIELD_NUMBER = 9;
  private google.events.cloud.iot.v1.HttpConfig httpConfig_;
  /**
   * <pre>
   * The DeviceService (HTTP) configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
   */
  @java.lang.Override
  public boolean hasHttpConfig() {
    return httpConfig_ != null;
  }
  /**
   * <pre>
   * The DeviceService (HTTP) configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
   */
  @java.lang.Override
  public google.events.cloud.iot.v1.HttpConfig getHttpConfig() {
    return httpConfig_ == null ? google.events.cloud.iot.v1.HttpConfig.getDefaultInstance() : httpConfig_;
  }
  /**
   * <pre>
   * The DeviceService (HTTP) configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
   */
  private void setHttpConfig(google.events.cloud.iot.v1.HttpConfig value) {
    value.getClass();
  httpConfig_ = value;
    
    }
  /**
   * <pre>
   * The DeviceService (HTTP) configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeHttpConfig(google.events.cloud.iot.v1.HttpConfig value) {
    value.getClass();
  if (httpConfig_ != null &&
        httpConfig_ != google.events.cloud.iot.v1.HttpConfig.getDefaultInstance()) {
      httpConfig_ =
        google.events.cloud.iot.v1.HttpConfig.newBuilder(httpConfig_).mergeFrom(value).buildPartial();
    } else {
      httpConfig_ = value;
    }
    
  }
  /**
   * <pre>
   * The DeviceService (HTTP) configuration for this device registry.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
   */
  private void clearHttpConfig() {  httpConfig_ = null;
    
  }

  public static final int LOG_LEVEL_FIELD_NUMBER = 11;
  private int logLevel_;
  /**
   * <pre>
   * **Beta Feature**
   * The default logging verbosity for activity from devices in this registry.
   * The verbosity level can be overridden by Device.log_level.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
   * @return The enum numeric value on the wire for logLevel.
   */
  @java.lang.Override
  public int getLogLevelValue() {
    return logLevel_;
  }
  /**
   * <pre>
   * **Beta Feature**
   * The default logging verbosity for activity from devices in this registry.
   * The verbosity level can be overridden by Device.log_level.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
   * @return The logLevel.
   */
  @java.lang.Override
  public google.events.cloud.iot.v1.LogLevel getLogLevel() {
    google.events.cloud.iot.v1.LogLevel result = google.events.cloud.iot.v1.LogLevel.forNumber(logLevel_);
    return result == null ? google.events.cloud.iot.v1.LogLevel.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * **Beta Feature**
   * The default logging verbosity for activity from devices in this registry.
   * The verbosity level can be overridden by Device.log_level.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
   * @param value The enum numeric value on the wire for logLevel to set.
   */
  private void setLogLevelValue(int value) {
      logLevel_ = value;
  }
  /**
   * <pre>
   * **Beta Feature**
   * The default logging verbosity for activity from devices in this registry.
   * The verbosity level can be overridden by Device.log_level.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
   * @param value The logLevel to set.
   */
  private void setLogLevel(google.events.cloud.iot.v1.LogLevel value) {
    logLevel_ = value.getNumber();
    
  }
  /**
   * <pre>
   * **Beta Feature**
   * The default logging verbosity for activity from devices in this registry.
   * The verbosity level can be overridden by Device.log_level.
   * </pre>
   *
   * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
   */
  private void clearLogLevel() {
    
    logLevel_ = 0;
  }

  public static final int CREDENTIALS_FIELD_NUMBER = 8;
  private com.google.protobuf.Internal.ProtobufList<google.events.cloud.iot.v1.RegistryCredential> credentials_;
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  @java.lang.Override
  public java.util.List<google.events.cloud.iot.v1.RegistryCredential> getCredentialsList() {
    return credentials_;
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  public java.util.List<? extends google.events.cloud.iot.v1.RegistryCredentialOrBuilder> 
      getCredentialsOrBuilderList() {
    return credentials_;
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  @java.lang.Override
  public int getCredentialsCount() {
    return credentials_.size();
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  @java.lang.Override
  public google.events.cloud.iot.v1.RegistryCredential getCredentials(int index) {
    return credentials_.get(index);
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  public google.events.cloud.iot.v1.RegistryCredentialOrBuilder getCredentialsOrBuilder(
      int index) {
    return credentials_.get(index);
  }
  private void ensureCredentialsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<google.events.cloud.iot.v1.RegistryCredential> tmp = credentials_;
    if (!tmp.isModifiable()) {
      credentials_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  private void setCredentials(
      int index, google.events.cloud.iot.v1.RegistryCredential value) {
    value.getClass();
  ensureCredentialsIsMutable();
    credentials_.set(index, value);
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  private void addCredentials(google.events.cloud.iot.v1.RegistryCredential value) {
    value.getClass();
  ensureCredentialsIsMutable();
    credentials_.add(value);
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  private void addCredentials(
      int index, google.events.cloud.iot.v1.RegistryCredential value) {
    value.getClass();
  ensureCredentialsIsMutable();
    credentials_.add(index, value);
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  private void addAllCredentials(
      java.lang.Iterable<? extends google.events.cloud.iot.v1.RegistryCredential> values) {
    ensureCredentialsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, credentials_);
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  private void clearCredentials() {
    credentials_ = emptyProtobufList();
  }
  /**
   * <pre>
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   * </pre>
   *
   * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
   */
  private void removeCredentials(int index) {
    ensureCredentialsIsMutable();
    credentials_.remove(index);
  }

  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static google.events.cloud.iot.v1.DeviceRegistry parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(google.events.cloud.iot.v1.DeviceRegistry prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * A container for a group of devices.
   * </pre>
   *
   * Protobuf type {@code google.events.cloud.iot.v1.DeviceRegistry}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        google.events.cloud.iot.v1.DeviceRegistry, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.events.cloud.iot.v1.DeviceRegistry)
      google.events.cloud.iot.v1.DeviceRegistryOrBuilder {
    // Construct using google.events.cloud.iot.v1.DeviceRegistry.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The identifier of this device registry. For example, `myRegistry`.
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      return instance.getId();
    }
    /**
     * <pre>
     * The identifier of this device registry. For example, `myRegistry`.
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      return instance.getIdBytes();
    }
    /**
     * <pre>
     * The identifier of this device registry. For example, `myRegistry`.
     * </pre>
     *
     * <code>string id = 1;</code>
     * @param value The id to set.
     * @return This builder for chaining.
     */
    public Builder setId(
        java.lang.String value) {
      copyOnWrite();
      instance.setId(value);
      return this;
    }
    /**
     * <pre>
     * The identifier of this device registry. For example, `myRegistry`.
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearId() {
      copyOnWrite();
      instance.clearId();
      return this;
    }
    /**
     * <pre>
     * The identifier of this device registry. For example, `myRegistry`.
     * </pre>
     *
     * <code>string id = 1;</code>
     * @param value The bytes for id to set.
     * @return This builder for chaining.
     */
    public Builder setIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * The resource path name. For example,
     * `projects/example-project/locations/us-central1/registries/my-registry`.
     * </pre>
     *
     * <code>string name = 2;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return instance.getName();
    }
    /**
     * <pre>
     * The resource path name. For example,
     * `projects/example-project/locations/us-central1/registries/my-registry`.
     * </pre>
     *
     * <code>string name = 2;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return instance.getNameBytes();
    }
    /**
     * <pre>
     * The resource path name. For example,
     * `projects/example-project/locations/us-central1/registries/my-registry`.
     * </pre>
     *
     * <code>string name = 2;</code>
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(
        java.lang.String value) {
      copyOnWrite();
      instance.setName(value);
      return this;
    }
    /**
     * <pre>
     * The resource path name. For example,
     * `projects/example-project/locations/us-central1/registries/my-registry`.
     * </pre>
     *
     * <code>string name = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearName() {
      copyOnWrite();
      instance.clearName();
      return this;
    }
    /**
     * <pre>
     * The resource path name. For example,
     * `projects/example-project/locations/us-central1/registries/my-registry`.
     * </pre>
     *
     * <code>string name = 2;</code>
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    @java.lang.Override
    public java.util.List<google.events.cloud.iot.v1.EventNotificationConfig> getEventNotificationConfigsList() {
      return java.util.Collections.unmodifiableList(
          instance.getEventNotificationConfigsList());
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    @java.lang.Override
    public int getEventNotificationConfigsCount() {
      return instance.getEventNotificationConfigsCount();
    }/**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    @java.lang.Override
    public google.events.cloud.iot.v1.EventNotificationConfig getEventNotificationConfigs(int index) {
      return instance.getEventNotificationConfigs(index);
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder setEventNotificationConfigs(
        int index, google.events.cloud.iot.v1.EventNotificationConfig value) {
      copyOnWrite();
      instance.setEventNotificationConfigs(index, value);
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder setEventNotificationConfigs(
        int index, google.events.cloud.iot.v1.EventNotificationConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setEventNotificationConfigs(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder addEventNotificationConfigs(google.events.cloud.iot.v1.EventNotificationConfig value) {
      copyOnWrite();
      instance.addEventNotificationConfigs(value);
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder addEventNotificationConfigs(
        int index, google.events.cloud.iot.v1.EventNotificationConfig value) {
      copyOnWrite();
      instance.addEventNotificationConfigs(index, value);
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder addEventNotificationConfigs(
        google.events.cloud.iot.v1.EventNotificationConfig.Builder builderForValue) {
      copyOnWrite();
      instance.addEventNotificationConfigs(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder addEventNotificationConfigs(
        int index, google.events.cloud.iot.v1.EventNotificationConfig.Builder builderForValue) {
      copyOnWrite();
      instance.addEventNotificationConfigs(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder addAllEventNotificationConfigs(
        java.lang.Iterable<? extends google.events.cloud.iot.v1.EventNotificationConfig> values) {
      copyOnWrite();
      instance.addAllEventNotificationConfigs(values);
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder clearEventNotificationConfigs() {
      copyOnWrite();
      instance.clearEventNotificationConfigs();
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of telemetry events received from the
     * device. All telemetry events that were successfully published by the
     * device and acknowledged by Cloud IoT Core are guaranteed to be
     * delivered to Cloud Pub/Sub. If multiple configurations match a message,
     * only the first matching configuration is used. If you try to publish a
     * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
     * for the device's registry, the connection closes automatically. If you try
     * to do so using an HTTP connection, an error is returned. Up to 10
     * configurations may be provided.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.EventNotificationConfig event_notification_configs = 10;</code>
     */
    public Builder removeEventNotificationConfigs(int index) {
      copyOnWrite();
      instance.removeEventNotificationConfigs(index);
      return this;
    }

    /**
     * <pre>
     * The configuration for notification of new states received from the device.
     * State updates are guaranteed to be stored in the state history, but
     * notifications to Cloud Pub/Sub are not guaranteed. For example, if
     * permissions are misconfigured or the specified topic doesn't exist, no
     * notification will be published but the state will still be stored in Cloud
     * IoT Core.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
     */
    @java.lang.Override
    public boolean hasStateNotificationConfig() {
      return instance.hasStateNotificationConfig();
    }
    /**
     * <pre>
     * The configuration for notification of new states received from the device.
     * State updates are guaranteed to be stored in the state history, but
     * notifications to Cloud Pub/Sub are not guaranteed. For example, if
     * permissions are misconfigured or the specified topic doesn't exist, no
     * notification will be published but the state will still be stored in Cloud
     * IoT Core.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
     */
    @java.lang.Override
    public google.events.cloud.iot.v1.StateNotificationConfig getStateNotificationConfig() {
      return instance.getStateNotificationConfig();
    }
    /**
     * <pre>
     * The configuration for notification of new states received from the device.
     * State updates are guaranteed to be stored in the state history, but
     * notifications to Cloud Pub/Sub are not guaranteed. For example, if
     * permissions are misconfigured or the specified topic doesn't exist, no
     * notification will be published but the state will still be stored in Cloud
     * IoT Core.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
     */
    public Builder setStateNotificationConfig(google.events.cloud.iot.v1.StateNotificationConfig value) {
      copyOnWrite();
      instance.setStateNotificationConfig(value);
      return this;
      }
    /**
     * <pre>
     * The configuration for notification of new states received from the device.
     * State updates are guaranteed to be stored in the state history, but
     * notifications to Cloud Pub/Sub are not guaranteed. For example, if
     * permissions are misconfigured or the specified topic doesn't exist, no
     * notification will be published but the state will still be stored in Cloud
     * IoT Core.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
     */
    public Builder setStateNotificationConfig(
        google.events.cloud.iot.v1.StateNotificationConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setStateNotificationConfig(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of new states received from the device.
     * State updates are guaranteed to be stored in the state history, but
     * notifications to Cloud Pub/Sub are not guaranteed. For example, if
     * permissions are misconfigured or the specified topic doesn't exist, no
     * notification will be published but the state will still be stored in Cloud
     * IoT Core.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
     */
    public Builder mergeStateNotificationConfig(google.events.cloud.iot.v1.StateNotificationConfig value) {
      copyOnWrite();
      instance.mergeStateNotificationConfig(value);
      return this;
    }
    /**
     * <pre>
     * The configuration for notification of new states received from the device.
     * State updates are guaranteed to be stored in the state history, but
     * notifications to Cloud Pub/Sub are not guaranteed. For example, if
     * permissions are misconfigured or the specified topic doesn't exist, no
     * notification will be published but the state will still be stored in Cloud
     * IoT Core.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.StateNotificationConfig state_notification_config = 7;</code>
     */
    public Builder clearStateNotificationConfig() {  copyOnWrite();
      instance.clearStateNotificationConfig();
      return this;
    }

    /**
     * <pre>
     * The MQTT configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
     */
    @java.lang.Override
    public boolean hasMqttConfig() {
      return instance.hasMqttConfig();
    }
    /**
     * <pre>
     * The MQTT configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
     */
    @java.lang.Override
    public google.events.cloud.iot.v1.MqttConfig getMqttConfig() {
      return instance.getMqttConfig();
    }
    /**
     * <pre>
     * The MQTT configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
     */
    public Builder setMqttConfig(google.events.cloud.iot.v1.MqttConfig value) {
      copyOnWrite();
      instance.setMqttConfig(value);
      return this;
      }
    /**
     * <pre>
     * The MQTT configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
     */
    public Builder setMqttConfig(
        google.events.cloud.iot.v1.MqttConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setMqttConfig(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The MQTT configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
     */
    public Builder mergeMqttConfig(google.events.cloud.iot.v1.MqttConfig value) {
      copyOnWrite();
      instance.mergeMqttConfig(value);
      return this;
    }
    /**
     * <pre>
     * The MQTT configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.MqttConfig mqtt_config = 4;</code>
     */
    public Builder clearMqttConfig() {  copyOnWrite();
      instance.clearMqttConfig();
      return this;
    }

    /**
     * <pre>
     * The DeviceService (HTTP) configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
     */
    @java.lang.Override
    public boolean hasHttpConfig() {
      return instance.hasHttpConfig();
    }
    /**
     * <pre>
     * The DeviceService (HTTP) configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
     */
    @java.lang.Override
    public google.events.cloud.iot.v1.HttpConfig getHttpConfig() {
      return instance.getHttpConfig();
    }
    /**
     * <pre>
     * The DeviceService (HTTP) configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
     */
    public Builder setHttpConfig(google.events.cloud.iot.v1.HttpConfig value) {
      copyOnWrite();
      instance.setHttpConfig(value);
      return this;
      }
    /**
     * <pre>
     * The DeviceService (HTTP) configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
     */
    public Builder setHttpConfig(
        google.events.cloud.iot.v1.HttpConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setHttpConfig(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The DeviceService (HTTP) configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
     */
    public Builder mergeHttpConfig(google.events.cloud.iot.v1.HttpConfig value) {
      copyOnWrite();
      instance.mergeHttpConfig(value);
      return this;
    }
    /**
     * <pre>
     * The DeviceService (HTTP) configuration for this device registry.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.HttpConfig http_config = 9;</code>
     */
    public Builder clearHttpConfig() {  copyOnWrite();
      instance.clearHttpConfig();
      return this;
    }

    /**
     * <pre>
     * **Beta Feature**
     * The default logging verbosity for activity from devices in this registry.
     * The verbosity level can be overridden by Device.log_level.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
     * @return The enum numeric value on the wire for logLevel.
     */
    @java.lang.Override
    public int getLogLevelValue() {
      return instance.getLogLevelValue();
    }
    /**
     * <pre>
     * **Beta Feature**
     * The default logging verbosity for activity from devices in this registry.
     * The verbosity level can be overridden by Device.log_level.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
     * @param value The logLevel to set.
     * @return This builder for chaining.
     */
    public Builder setLogLevelValue(int value) {
      copyOnWrite();
      instance.setLogLevelValue(value);
      return this;
    }
    /**
     * <pre>
     * **Beta Feature**
     * The default logging verbosity for activity from devices in this registry.
     * The verbosity level can be overridden by Device.log_level.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
     * @return The logLevel.
     */
    @java.lang.Override
    public google.events.cloud.iot.v1.LogLevel getLogLevel() {
      return instance.getLogLevel();
    }
    /**
     * <pre>
     * **Beta Feature**
     * The default logging verbosity for activity from devices in this registry.
     * The verbosity level can be overridden by Device.log_level.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
     * @param value The enum numeric value on the wire for logLevel to set.
     * @return This builder for chaining.
     */
    public Builder setLogLevel(google.events.cloud.iot.v1.LogLevel value) {
      copyOnWrite();
      instance.setLogLevel(value);
      return this;
    }
    /**
     * <pre>
     * **Beta Feature**
     * The default logging verbosity for activity from devices in this registry.
     * The verbosity level can be overridden by Device.log_level.
     * </pre>
     *
     * <code>.google.events.cloud.iot.v1.LogLevel log_level = 11;</code>
     * @return This builder for chaining.
     */
    public Builder clearLogLevel() {
      copyOnWrite();
      instance.clearLogLevel();
      return this;
    }

    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    @java.lang.Override
    public java.util.List<google.events.cloud.iot.v1.RegistryCredential> getCredentialsList() {
      return java.util.Collections.unmodifiableList(
          instance.getCredentialsList());
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    @java.lang.Override
    public int getCredentialsCount() {
      return instance.getCredentialsCount();
    }/**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    @java.lang.Override
    public google.events.cloud.iot.v1.RegistryCredential getCredentials(int index) {
      return instance.getCredentials(index);
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder setCredentials(
        int index, google.events.cloud.iot.v1.RegistryCredential value) {
      copyOnWrite();
      instance.setCredentials(index, value);
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder setCredentials(
        int index, google.events.cloud.iot.v1.RegistryCredential.Builder builderForValue) {
      copyOnWrite();
      instance.setCredentials(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder addCredentials(google.events.cloud.iot.v1.RegistryCredential value) {
      copyOnWrite();
      instance.addCredentials(value);
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder addCredentials(
        int index, google.events.cloud.iot.v1.RegistryCredential value) {
      copyOnWrite();
      instance.addCredentials(index, value);
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder addCredentials(
        google.events.cloud.iot.v1.RegistryCredential.Builder builderForValue) {
      copyOnWrite();
      instance.addCredentials(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder addCredentials(
        int index, google.events.cloud.iot.v1.RegistryCredential.Builder builderForValue) {
      copyOnWrite();
      instance.addCredentials(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder addAllCredentials(
        java.lang.Iterable<? extends google.events.cloud.iot.v1.RegistryCredential> values) {
      copyOnWrite();
      instance.addAllCredentials(values);
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder clearCredentials() {
      copyOnWrite();
      instance.clearCredentials();
      return this;
    }
    /**
     * <pre>
     * The credentials used to verify the device credentials. No more than 10
     * credentials can be bound to a single registry at a time. The verification
     * process occurs at the time of device creation or update. If this field is
     * empty, no verification is performed. Otherwise, the credentials of a newly
     * created device or added credentials of an updated device should be signed
     * with one of these registry credentials.
     * Note, however, that existing devices will never be affected by
     * modifications to this list of credentials: after a device has been
     * successfully created in a registry, it should be able to connect even if
     * its registry credentials are revoked, deleted, or modified.
     * </pre>
     *
     * <code>repeated .google.events.cloud.iot.v1.RegistryCredential credentials = 8;</code>
     */
    public Builder removeCredentials(int index) {
      copyOnWrite();
      instance.removeCredentials(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.events.cloud.iot.v1.DeviceRegistry)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new google.events.cloud.iot.v1.DeviceRegistry();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "id_",
            "name_",
            "mqttConfig_",
            "stateNotificationConfig_",
            "credentials_",
            google.events.cloud.iot.v1.RegistryCredential.class,
            "httpConfig_",
            "eventNotificationConfigs_",
            google.events.cloud.iot.v1.EventNotificationConfig.class,
            "logLevel_",
          };
          java.lang.String info =
              "\u0000\b\u0000\u0000\u0001\u000b\b\u0000\u0002\u0000\u0001\u0208\u0002\u0208\u0004" +
              "\t\u0007\t\b\u001b\t\t\n\u001b\u000b\f";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<google.events.cloud.iot.v1.DeviceRegistry> parser = PARSER;
        if (parser == null) {
          synchronized (google.events.cloud.iot.v1.DeviceRegistry.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<google.events.cloud.iot.v1.DeviceRegistry>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.events.cloud.iot.v1.DeviceRegistry)
  private static final google.events.cloud.iot.v1.DeviceRegistry DEFAULT_INSTANCE;
  static {
    DeviceRegistry defaultInstance = new DeviceRegistry();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      DeviceRegistry.class, defaultInstance);
  }

  public static google.events.cloud.iot.v1.DeviceRegistry getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<DeviceRegistry> PARSER;

  public static com.google.protobuf.Parser<DeviceRegistry> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

