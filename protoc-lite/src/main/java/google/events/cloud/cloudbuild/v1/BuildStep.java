// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/events/cloud/cloudbuild/v1/data.proto

package google.events.cloud.cloudbuild.v1;

/**
 * <pre>
 * A step in the build pipeline.
 * </pre>
 *
 * Protobuf type {@code google.events.cloud.cloudbuild.v1.BuildStep}
 */
public  final class BuildStep extends
    com.google.protobuf.GeneratedMessageLite<
        BuildStep, BuildStep.Builder> implements
    // @@protoc_insertion_point(message_implements:google.events.cloud.cloudbuild.v1.BuildStep)
    BuildStepOrBuilder {
  private BuildStep() {
    name_ = "";
    env_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    args_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    dir_ = "";
    id_ = "";
    waitFor_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    entrypoint_ = "";
    secretEnv_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    volumes_ = emptyProtobufList();
  }
  public static final int NAME_FIELD_NUMBER = 1;
  private java.lang.String name_;
  /**
   * <pre>
   * The name of the container image that will run this particular
   * build step.
   * If the image is available in the host's Docker daemon's cache, it
   * will be run directly. If not, the host will attempt to pull the image
   * first, using the builder service account's credentials if necessary.
   * The Docker daemon's cache will already have the latest versions of all of
   * the officially supported build steps
   * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
   * The Docker daemon will also have cached many of the layers for some popular
   * images, like "ubuntu", "debian", but they will be refreshed at the time you
   * attempt to use them.
   * If you built an image in a previous build step, it will be stored in the
   * host's Docker daemon's cache and is available to use as the name for a
   * later build step.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    return name_;
  }
  /**
   * <pre>
   * The name of the container image that will run this particular
   * build step.
   * If the image is available in the host's Docker daemon's cache, it
   * will be run directly. If not, the host will attempt to pull the image
   * first, using the builder service account's credentials if necessary.
   * The Docker daemon's cache will already have the latest versions of all of
   * the officially supported build steps
   * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
   * The Docker daemon will also have cached many of the layers for some popular
   * images, like "ubuntu", "debian", but they will be refreshed at the time you
   * attempt to use them.
   * If you built an image in a previous build step, it will be stored in the
   * host's Docker daemon's cache and is available to use as the name for a
   * later build step.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(name_);
  }
  /**
   * <pre>
   * The name of the container image that will run this particular
   * build step.
   * If the image is available in the host's Docker daemon's cache, it
   * will be run directly. If not, the host will attempt to pull the image
   * first, using the builder service account's credentials if necessary.
   * The Docker daemon's cache will already have the latest versions of all of
   * the officially supported build steps
   * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
   * The Docker daemon will also have cached many of the layers for some popular
   * images, like "ubuntu", "debian", but they will be refreshed at the time you
   * attempt to use them.
   * If you built an image in a previous build step, it will be stored in the
   * host's Docker daemon's cache and is available to use as the name for a
   * later build step.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @param value The name to set.
   */
  private void setName(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    name_ = value;
  }
  /**
   * <pre>
   * The name of the container image that will run this particular
   * build step.
   * If the image is available in the host's Docker daemon's cache, it
   * will be run directly. If not, the host will attempt to pull the image
   * first, using the builder service account's credentials if necessary.
   * The Docker daemon's cache will already have the latest versions of all of
   * the officially supported build steps
   * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
   * The Docker daemon will also have cached many of the layers for some popular
   * images, like "ubuntu", "debian", but they will be refreshed at the time you
   * attempt to use them.
   * If you built an image in a previous build step, it will be stored in the
   * host's Docker daemon's cache and is available to use as the name for a
   * later build step.
   * </pre>
   *
   * <code>string name = 1;</code>
   */
  private void clearName() {
    
    name_ = getDefaultInstance().getName();
  }
  /**
   * <pre>
   * The name of the container image that will run this particular
   * build step.
   * If the image is available in the host's Docker daemon's cache, it
   * will be run directly. If not, the host will attempt to pull the image
   * first, using the builder service account's credentials if necessary.
   * The Docker daemon's cache will already have the latest versions of all of
   * the officially supported build steps
   * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
   * The Docker daemon will also have cached many of the layers for some popular
   * images, like "ubuntu", "debian", but they will be refreshed at the time you
   * attempt to use them.
   * If you built an image in a previous build step, it will be stored in the
   * host's Docker daemon's cache and is available to use as the name for a
   * later build step.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @param value The bytes for name to set.
   */
  private void setNameBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    name_ = value.toStringUtf8();
    
  }

  public static final int ENV_FIELD_NUMBER = 2;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> env_;
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @return A list containing the env.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getEnvList() {
    return env_;
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @return The count of env.
   */
  @java.lang.Override
  public int getEnvCount() {
    return env_.size();
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @param index The index of the element to return.
   * @return The env at the given index.
   */
  @java.lang.Override
  public java.lang.String getEnv(int index) {
    return env_.get(index);
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @param index The index of the value to return.
   * @return The bytes of the env at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getEnvBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        env_.get(index));
  }
  private void ensureEnvIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        env_;  if (!tmp.isModifiable()) {
      env_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @param index The index to set the value at.
   * @param value The env to set.
   */
  private void setEnv(
      int index, java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureEnvIsMutable();
    env_.set(index, value);
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @param value The env to add.
   */
  private void addEnv(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureEnvIsMutable();
    env_.add(value);
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @param values The env to add.
   */
  private void addAllEnv(
      java.lang.Iterable<java.lang.String> values) {
    ensureEnvIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, env_);
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   */
  private void clearEnv() {
    env_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * A list of environment variable definitions to be used when running a step.
   * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
   * being given the value "VALUE".
   * </pre>
   *
   * <code>repeated string env = 2;</code>
   * @param value The bytes of the env to add.
   */
  private void addEnvBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    ensureEnvIsMutable();
    env_.add(value.toStringUtf8());
  }

  public static final int ARGS_FIELD_NUMBER = 3;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> args_;
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @return A list containing the args.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getArgsList() {
    return args_;
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @return The count of args.
   */
  @java.lang.Override
  public int getArgsCount() {
    return args_.size();
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @param index The index of the element to return.
   * @return The args at the given index.
   */
  @java.lang.Override
  public java.lang.String getArgs(int index) {
    return args_.get(index);
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @param index The index of the value to return.
   * @return The bytes of the args at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getArgsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        args_.get(index));
  }
  private void ensureArgsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        args_;  if (!tmp.isModifiable()) {
      args_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @param index The index to set the value at.
   * @param value The args to set.
   */
  private void setArgs(
      int index, java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureArgsIsMutable();
    args_.set(index, value);
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @param value The args to add.
   */
  private void addArgs(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureArgsIsMutable();
    args_.add(value);
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @param values The args to add.
   */
  private void addAllArgs(
      java.lang.Iterable<java.lang.String> values) {
    ensureArgsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, args_);
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   */
  private void clearArgs() {
    args_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * A list of arguments that will be presented to the step when it is started.
   * If the image used to run the step's container has an entrypoint, the `args`
   * are used as arguments to that entrypoint. If the image does not define
   * an entrypoint, the first element in args is used as the entrypoint,
   * and the remainder will be used as arguments.
   * </pre>
   *
   * <code>repeated string args = 3;</code>
   * @param value The bytes of the args to add.
   */
  private void addArgsBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    ensureArgsIsMutable();
    args_.add(value.toStringUtf8());
  }

  public static final int DIR_FIELD_NUMBER = 4;
  private java.lang.String dir_;
  /**
   * <pre>
   * Working directory to use when running this step's container.
   * If this value is a relative path, it is relative to the build's working
   * directory. If this value is absolute, it may be outside the build's working
   * directory, in which case the contents of the path may not be persisted
   * across build step executions, unless a `volume` for that path is specified.
   * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
   * which specifies an absolute path, the `RepoSource` `dir` is ignored for
   * the step's execution.
   * </pre>
   *
   * <code>string dir = 4;</code>
   * @return The dir.
   */
  @java.lang.Override
  public java.lang.String getDir() {
    return dir_;
  }
  /**
   * <pre>
   * Working directory to use when running this step's container.
   * If this value is a relative path, it is relative to the build's working
   * directory. If this value is absolute, it may be outside the build's working
   * directory, in which case the contents of the path may not be persisted
   * across build step executions, unless a `volume` for that path is specified.
   * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
   * which specifies an absolute path, the `RepoSource` `dir` is ignored for
   * the step's execution.
   * </pre>
   *
   * <code>string dir = 4;</code>
   * @return The bytes for dir.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getDirBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(dir_);
  }
  /**
   * <pre>
   * Working directory to use when running this step's container.
   * If this value is a relative path, it is relative to the build's working
   * directory. If this value is absolute, it may be outside the build's working
   * directory, in which case the contents of the path may not be persisted
   * across build step executions, unless a `volume` for that path is specified.
   * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
   * which specifies an absolute path, the `RepoSource` `dir` is ignored for
   * the step's execution.
   * </pre>
   *
   * <code>string dir = 4;</code>
   * @param value The dir to set.
   */
  private void setDir(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    dir_ = value;
  }
  /**
   * <pre>
   * Working directory to use when running this step's container.
   * If this value is a relative path, it is relative to the build's working
   * directory. If this value is absolute, it may be outside the build's working
   * directory, in which case the contents of the path may not be persisted
   * across build step executions, unless a `volume` for that path is specified.
   * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
   * which specifies an absolute path, the `RepoSource` `dir` is ignored for
   * the step's execution.
   * </pre>
   *
   * <code>string dir = 4;</code>
   */
  private void clearDir() {
    
    dir_ = getDefaultInstance().getDir();
  }
  /**
   * <pre>
   * Working directory to use when running this step's container.
   * If this value is a relative path, it is relative to the build's working
   * directory. If this value is absolute, it may be outside the build's working
   * directory, in which case the contents of the path may not be persisted
   * across build step executions, unless a `volume` for that path is specified.
   * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
   * which specifies an absolute path, the `RepoSource` `dir` is ignored for
   * the step's execution.
   * </pre>
   *
   * <code>string dir = 4;</code>
   * @param value The bytes for dir to set.
   */
  private void setDirBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    dir_ = value.toStringUtf8();
    
  }

  public static final int ID_FIELD_NUMBER = 5;
  private java.lang.String id_;
  /**
   * <pre>
   * Unique identifier for this build step, used in `wait_for` to
   * reference this build step as a dependency.
   * </pre>
   *
   * <code>string id = 5;</code>
   * @return The id.
   */
  @java.lang.Override
  public java.lang.String getId() {
    return id_;
  }
  /**
   * <pre>
   * Unique identifier for this build step, used in `wait_for` to
   * reference this build step as a dependency.
   * </pre>
   *
   * <code>string id = 5;</code>
   * @return The bytes for id.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(id_);
  }
  /**
   * <pre>
   * Unique identifier for this build step, used in `wait_for` to
   * reference this build step as a dependency.
   * </pre>
   *
   * <code>string id = 5;</code>
   * @param value The id to set.
   */
  private void setId(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    id_ = value;
  }
  /**
   * <pre>
   * Unique identifier for this build step, used in `wait_for` to
   * reference this build step as a dependency.
   * </pre>
   *
   * <code>string id = 5;</code>
   */
  private void clearId() {
    
    id_ = getDefaultInstance().getId();
  }
  /**
   * <pre>
   * Unique identifier for this build step, used in `wait_for` to
   * reference this build step as a dependency.
   * </pre>
   *
   * <code>string id = 5;</code>
   * @param value The bytes for id to set.
   */
  private void setIdBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    id_ = value.toStringUtf8();
    
  }

  public static final int WAIT_FOR_FIELD_NUMBER = 6;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> waitFor_;
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @return A list containing the waitFor.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getWaitForList() {
    return waitFor_;
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @return The count of waitFor.
   */
  @java.lang.Override
  public int getWaitForCount() {
    return waitFor_.size();
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @param index The index of the element to return.
   * @return The waitFor at the given index.
   */
  @java.lang.Override
  public java.lang.String getWaitFor(int index) {
    return waitFor_.get(index);
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @param index The index of the value to return.
   * @return The bytes of the waitFor at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getWaitForBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        waitFor_.get(index));
  }
  private void ensureWaitForIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        waitFor_;  if (!tmp.isModifiable()) {
      waitFor_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @param index The index to set the value at.
   * @param value The waitFor to set.
   */
  private void setWaitFor(
      int index, java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureWaitForIsMutable();
    waitFor_.set(index, value);
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @param value The waitFor to add.
   */
  private void addWaitFor(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureWaitForIsMutable();
    waitFor_.add(value);
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @param values The waitFor to add.
   */
  private void addAllWaitFor(
      java.lang.Iterable<java.lang.String> values) {
    ensureWaitForIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, waitFor_);
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   */
  private void clearWaitFor() {
    waitFor_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * The ID(s) of the step(s) that this build step depends on.
   * This build step will not start until all the build steps in `wait_for`
   * have completed successfully. If `wait_for` is empty, this build step will
   * start when all previous build steps in the `Build.Steps` list have
   * completed successfully.
   * </pre>
   *
   * <code>repeated string wait_for = 6;</code>
   * @param value The bytes of the waitFor to add.
   */
  private void addWaitForBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    ensureWaitForIsMutable();
    waitFor_.add(value.toStringUtf8());
  }

  public static final int ENTRYPOINT_FIELD_NUMBER = 7;
  private java.lang.String entrypoint_;
  /**
   * <pre>
   * Entrypoint to be used instead of the build step image's default entrypoint.
   * If unset, the image's default entrypoint is used.
   * </pre>
   *
   * <code>string entrypoint = 7;</code>
   * @return The entrypoint.
   */
  @java.lang.Override
  public java.lang.String getEntrypoint() {
    return entrypoint_;
  }
  /**
   * <pre>
   * Entrypoint to be used instead of the build step image's default entrypoint.
   * If unset, the image's default entrypoint is used.
   * </pre>
   *
   * <code>string entrypoint = 7;</code>
   * @return The bytes for entrypoint.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getEntrypointBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(entrypoint_);
  }
  /**
   * <pre>
   * Entrypoint to be used instead of the build step image's default entrypoint.
   * If unset, the image's default entrypoint is used.
   * </pre>
   *
   * <code>string entrypoint = 7;</code>
   * @param value The entrypoint to set.
   */
  private void setEntrypoint(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    entrypoint_ = value;
  }
  /**
   * <pre>
   * Entrypoint to be used instead of the build step image's default entrypoint.
   * If unset, the image's default entrypoint is used.
   * </pre>
   *
   * <code>string entrypoint = 7;</code>
   */
  private void clearEntrypoint() {
    
    entrypoint_ = getDefaultInstance().getEntrypoint();
  }
  /**
   * <pre>
   * Entrypoint to be used instead of the build step image's default entrypoint.
   * If unset, the image's default entrypoint is used.
   * </pre>
   *
   * <code>string entrypoint = 7;</code>
   * @param value The bytes for entrypoint to set.
   */
  private void setEntrypointBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    entrypoint_ = value.toStringUtf8();
    
  }

  public static final int SECRET_ENV_FIELD_NUMBER = 8;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> secretEnv_;
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @return A list containing the secretEnv.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getSecretEnvList() {
    return secretEnv_;
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @return The count of secretEnv.
   */
  @java.lang.Override
  public int getSecretEnvCount() {
    return secretEnv_.size();
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @param index The index of the element to return.
   * @return The secretEnv at the given index.
   */
  @java.lang.Override
  public java.lang.String getSecretEnv(int index) {
    return secretEnv_.get(index);
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @param index The index of the value to return.
   * @return The bytes of the secretEnv at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSecretEnvBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        secretEnv_.get(index));
  }
  private void ensureSecretEnvIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        secretEnv_;  if (!tmp.isModifiable()) {
      secretEnv_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @param index The index to set the value at.
   * @param value The secretEnv to set.
   */
  private void setSecretEnv(
      int index, java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureSecretEnvIsMutable();
    secretEnv_.set(index, value);
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @param value The secretEnv to add.
   */
  private void addSecretEnv(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureSecretEnvIsMutable();
    secretEnv_.add(value);
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @param values The secretEnv to add.
   */
  private void addAllSecretEnv(
      java.lang.Iterable<java.lang.String> values) {
    ensureSecretEnvIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, secretEnv_);
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   */
  private void clearSecretEnv() {
    secretEnv_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * A list of environment variables which are encrypted using a Cloud Key
   * Management Service crypto key. These values must be specified in the
   * build's `Secret`.
   * </pre>
   *
   * <code>repeated string secret_env = 8;</code>
   * @param value The bytes of the secretEnv to add.
   */
  private void addSecretEnvBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    ensureSecretEnvIsMutable();
    secretEnv_.add(value.toStringUtf8());
  }

  public static final int VOLUMES_FIELD_NUMBER = 9;
  private com.google.protobuf.Internal.ProtobufList<google.events.cloud.cloudbuild.v1.Volume> volumes_;
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  @java.lang.Override
  public java.util.List<google.events.cloud.cloudbuild.v1.Volume> getVolumesList() {
    return volumes_;
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  public java.util.List<? extends google.events.cloud.cloudbuild.v1.VolumeOrBuilder> 
      getVolumesOrBuilderList() {
    return volumes_;
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  @java.lang.Override
  public int getVolumesCount() {
    return volumes_.size();
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  @java.lang.Override
  public google.events.cloud.cloudbuild.v1.Volume getVolumes(int index) {
    return volumes_.get(index);
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  public google.events.cloud.cloudbuild.v1.VolumeOrBuilder getVolumesOrBuilder(
      int index) {
    return volumes_.get(index);
  }
  private void ensureVolumesIsMutable() {
    com.google.protobuf.Internal.ProtobufList<google.events.cloud.cloudbuild.v1.Volume> tmp = volumes_;
    if (!tmp.isModifiable()) {
      volumes_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  private void setVolumes(
      int index, google.events.cloud.cloudbuild.v1.Volume value) {
    value.getClass();
  ensureVolumesIsMutable();
    volumes_.set(index, value);
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  private void addVolumes(google.events.cloud.cloudbuild.v1.Volume value) {
    value.getClass();
  ensureVolumesIsMutable();
    volumes_.add(value);
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  private void addVolumes(
      int index, google.events.cloud.cloudbuild.v1.Volume value) {
    value.getClass();
  ensureVolumesIsMutable();
    volumes_.add(index, value);
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  private void addAllVolumes(
      java.lang.Iterable<? extends google.events.cloud.cloudbuild.v1.Volume> values) {
    ensureVolumesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, volumes_);
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  private void clearVolumes() {
    volumes_ = emptyProtobufList();
  }
  /**
   * <pre>
   * List of volumes to mount into the build step.
   * Each volume is created as an empty volume prior to execution of the
   * build step. Upon completion of the build, volumes and their contents are
   * discarded.
   * Using a named volume in only one step is not valid as it is indicative
   * of a build request with an incorrect configuration.
   * </pre>
   *
   * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
   */
  private void removeVolumes(int index) {
    ensureVolumesIsMutable();
    volumes_.remove(index);
  }

  public static final int TIMING_FIELD_NUMBER = 10;
  private google.events.cloud.cloudbuild.v1.TimeSpan timing_;
  /**
   * <pre>
   * Stores timing information for executing this build step.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
   */
  @java.lang.Override
  public boolean hasTiming() {
    return timing_ != null;
  }
  /**
   * <pre>
   * Stores timing information for executing this build step.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
   */
  @java.lang.Override
  public google.events.cloud.cloudbuild.v1.TimeSpan getTiming() {
    return timing_ == null ? google.events.cloud.cloudbuild.v1.TimeSpan.getDefaultInstance() : timing_;
  }
  /**
   * <pre>
   * Stores timing information for executing this build step.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
   */
  private void setTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
    value.getClass();
  timing_ = value;
    
    }
  /**
   * <pre>
   * Stores timing information for executing this build step.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
    value.getClass();
  if (timing_ != null &&
        timing_ != google.events.cloud.cloudbuild.v1.TimeSpan.getDefaultInstance()) {
      timing_ =
        google.events.cloud.cloudbuild.v1.TimeSpan.newBuilder(timing_).mergeFrom(value).buildPartial();
    } else {
      timing_ = value;
    }
    
  }
  /**
   * <pre>
   * Stores timing information for executing this build step.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
   */
  private void clearTiming() {  timing_ = null;
    
  }

  public static final int PULL_TIMING_FIELD_NUMBER = 13;
  private google.events.cloud.cloudbuild.v1.TimeSpan pullTiming_;
  /**
   * <pre>
   * Stores timing information for pulling this build step's
   * builder image only.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
   */
  @java.lang.Override
  public boolean hasPullTiming() {
    return pullTiming_ != null;
  }
  /**
   * <pre>
   * Stores timing information for pulling this build step's
   * builder image only.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
   */
  @java.lang.Override
  public google.events.cloud.cloudbuild.v1.TimeSpan getPullTiming() {
    return pullTiming_ == null ? google.events.cloud.cloudbuild.v1.TimeSpan.getDefaultInstance() : pullTiming_;
  }
  /**
   * <pre>
   * Stores timing information for pulling this build step's
   * builder image only.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
   */
  private void setPullTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
    value.getClass();
  pullTiming_ = value;
    
    }
  /**
   * <pre>
   * Stores timing information for pulling this build step's
   * builder image only.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergePullTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
    value.getClass();
  if (pullTiming_ != null &&
        pullTiming_ != google.events.cloud.cloudbuild.v1.TimeSpan.getDefaultInstance()) {
      pullTiming_ =
        google.events.cloud.cloudbuild.v1.TimeSpan.newBuilder(pullTiming_).mergeFrom(value).buildPartial();
    } else {
      pullTiming_ = value;
    }
    
  }
  /**
   * <pre>
   * Stores timing information for pulling this build step's
   * builder image only.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
   */
  private void clearPullTiming() {  pullTiming_ = null;
    
  }

  public static final int TIMEOUT_FIELD_NUMBER = 11;
  private com.google.protobuf.Duration timeout_;
  /**
   * <pre>
   * Time limit for executing this build step. If not defined, the step has no
   * time limit and will be allowed to continue to run until either it completes
   * or the build itself times out.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 11;</code>
   */
  @java.lang.Override
  public boolean hasTimeout() {
    return timeout_ != null;
  }
  /**
   * <pre>
   * Time limit for executing this build step. If not defined, the step has no
   * time limit and will be allowed to continue to run until either it completes
   * or the build itself times out.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 11;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Duration getTimeout() {
    return timeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeout_;
  }
  /**
   * <pre>
   * Time limit for executing this build step. If not defined, the step has no
   * time limit and will be allowed to continue to run until either it completes
   * or the build itself times out.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 11;</code>
   */
  private void setTimeout(com.google.protobuf.Duration value) {
    value.getClass();
  timeout_ = value;
    
    }
  /**
   * <pre>
   * Time limit for executing this build step. If not defined, the step has no
   * time limit and will be allowed to continue to run until either it completes
   * or the build itself times out.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 11;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeTimeout(com.google.protobuf.Duration value) {
    value.getClass();
  if (timeout_ != null &&
        timeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
      timeout_ =
        com.google.protobuf.Duration.newBuilder(timeout_).mergeFrom(value).buildPartial();
    } else {
      timeout_ = value;
    }
    
  }
  /**
   * <pre>
   * Time limit for executing this build step. If not defined, the step has no
   * time limit and will be allowed to continue to run until either it completes
   * or the build itself times out.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 11;</code>
   */
  private void clearTimeout() {  timeout_ = null;
    
  }

  public static final int STATUS_FIELD_NUMBER = 12;
  private int status_;
  /**
   * <pre>
   * Status of the build step. At this time, build step status is
   * only updated on build completion; step status is not updated in real-time
   * as the build progresses.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
   * @return The enum numeric value on the wire for status.
   */
  @java.lang.Override
  public int getStatusValue() {
    return status_;
  }
  /**
   * <pre>
   * Status of the build step. At this time, build step status is
   * only updated on build completion; step status is not updated in real-time
   * as the build progresses.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
   * @return The status.
   */
  @java.lang.Override
  public google.events.cloud.cloudbuild.v1.BuildEventData.Status getStatus() {
    google.events.cloud.cloudbuild.v1.BuildEventData.Status result = google.events.cloud.cloudbuild.v1.BuildEventData.Status.forNumber(status_);
    return result == null ? google.events.cloud.cloudbuild.v1.BuildEventData.Status.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * Status of the build step. At this time, build step status is
   * only updated on build completion; step status is not updated in real-time
   * as the build progresses.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
   * @param value The enum numeric value on the wire for status to set.
   */
  private void setStatusValue(int value) {
      status_ = value;
  }
  /**
   * <pre>
   * Status of the build step. At this time, build step status is
   * only updated on build completion; step status is not updated in real-time
   * as the build progresses.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
   * @param value The status to set.
   */
  private void setStatus(google.events.cloud.cloudbuild.v1.BuildEventData.Status value) {
    status_ = value.getNumber();
    
  }
  /**
   * <pre>
   * Status of the build step. At this time, build step status is
   * only updated on build completion; step status is not updated in real-time
   * as the build progresses.
   * </pre>
   *
   * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
   */
  private void clearStatus() {
    
    status_ = 0;
  }

  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static google.events.cloud.cloudbuild.v1.BuildStep parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(google.events.cloud.cloudbuild.v1.BuildStep prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * A step in the build pipeline.
   * </pre>
   *
   * Protobuf type {@code google.events.cloud.cloudbuild.v1.BuildStep}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        google.events.cloud.cloudbuild.v1.BuildStep, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.events.cloud.cloudbuild.v1.BuildStep)
      google.events.cloud.cloudbuild.v1.BuildStepOrBuilder {
    // Construct using google.events.cloud.cloudbuild.v1.BuildStep.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The name of the container image that will run this particular
     * build step.
     * If the image is available in the host's Docker daemon's cache, it
     * will be run directly. If not, the host will attempt to pull the image
     * first, using the builder service account's credentials if necessary.
     * The Docker daemon's cache will already have the latest versions of all of
     * the officially supported build steps
     * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
     * The Docker daemon will also have cached many of the layers for some popular
     * images, like "ubuntu", "debian", but they will be refreshed at the time you
     * attempt to use them.
     * If you built an image in a previous build step, it will be stored in the
     * host's Docker daemon's cache and is available to use as the name for a
     * later build step.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return instance.getName();
    }
    /**
     * <pre>
     * The name of the container image that will run this particular
     * build step.
     * If the image is available in the host's Docker daemon's cache, it
     * will be run directly. If not, the host will attempt to pull the image
     * first, using the builder service account's credentials if necessary.
     * The Docker daemon's cache will already have the latest versions of all of
     * the officially supported build steps
     * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
     * The Docker daemon will also have cached many of the layers for some popular
     * images, like "ubuntu", "debian", but they will be refreshed at the time you
     * attempt to use them.
     * If you built an image in a previous build step, it will be stored in the
     * host's Docker daemon's cache and is available to use as the name for a
     * later build step.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return instance.getNameBytes();
    }
    /**
     * <pre>
     * The name of the container image that will run this particular
     * build step.
     * If the image is available in the host's Docker daemon's cache, it
     * will be run directly. If not, the host will attempt to pull the image
     * first, using the builder service account's credentials if necessary.
     * The Docker daemon's cache will already have the latest versions of all of
     * the officially supported build steps
     * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
     * The Docker daemon will also have cached many of the layers for some popular
     * images, like "ubuntu", "debian", but they will be refreshed at the time you
     * attempt to use them.
     * If you built an image in a previous build step, it will be stored in the
     * host's Docker daemon's cache and is available to use as the name for a
     * later build step.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(
        java.lang.String value) {
      copyOnWrite();
      instance.setName(value);
      return this;
    }
    /**
     * <pre>
     * The name of the container image that will run this particular
     * build step.
     * If the image is available in the host's Docker daemon's cache, it
     * will be run directly. If not, the host will attempt to pull the image
     * first, using the builder service account's credentials if necessary.
     * The Docker daemon's cache will already have the latest versions of all of
     * the officially supported build steps
     * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
     * The Docker daemon will also have cached many of the layers for some popular
     * images, like "ubuntu", "debian", but they will be refreshed at the time you
     * attempt to use them.
     * If you built an image in a previous build step, it will be stored in the
     * host's Docker daemon's cache and is available to use as the name for a
     * later build step.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearName() {
      copyOnWrite();
      instance.clearName();
      return this;
    }
    /**
     * <pre>
     * The name of the container image that will run this particular
     * build step.
     * If the image is available in the host's Docker daemon's cache, it
     * will be run directly. If not, the host will attempt to pull the image
     * first, using the builder service account's credentials if necessary.
     * The Docker daemon's cache will already have the latest versions of all of
     * the officially supported build steps
     * ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
     * The Docker daemon will also have cached many of the layers for some popular
     * images, like "ubuntu", "debian", but they will be refreshed at the time you
     * attempt to use them.
     * If you built an image in a previous build step, it will be stored in the
     * host's Docker daemon's cache and is available to use as the name for a
     * later build step.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @return A list containing the env.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getEnvList() {
      return java.util.Collections.unmodifiableList(
          instance.getEnvList());
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @return The count of env.
     */
    @java.lang.Override
    public int getEnvCount() {
      return instance.getEnvCount();
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @param index The index of the element to return.
     * @return The env at the given index.
     */
    @java.lang.Override
    public java.lang.String getEnv(int index) {
      return instance.getEnv(index);
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the env at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEnvBytes(int index) {
      return instance.getEnvBytes(index);
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @param index The index to set the value at.
     * @param value The env to set.
     * @return This builder for chaining.
     */
    public Builder setEnv(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setEnv(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @param value The env to add.
     * @return This builder for chaining.
     */
    public Builder addEnv(
        java.lang.String value) {
      copyOnWrite();
      instance.addEnv(value);
      return this;
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @param values The env to add.
     * @return This builder for chaining.
     */
    public Builder addAllEnv(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllEnv(values);
      return this;
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearEnv() {
      copyOnWrite();
      instance.clearEnv();
      return this;
    }
    /**
     * <pre>
     * A list of environment variable definitions to be used when running a step.
     * The elements are of the form "KEY=VALUE" for the environment variable "KEY"
     * being given the value "VALUE".
     * </pre>
     *
     * <code>repeated string env = 2;</code>
     * @param value The bytes of the env to add.
     * @return This builder for chaining.
     */
    public Builder addEnvBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addEnvBytes(value);
      return this;
    }

    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @return A list containing the args.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getArgsList() {
      return java.util.Collections.unmodifiableList(
          instance.getArgsList());
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @return The count of args.
     */
    @java.lang.Override
    public int getArgsCount() {
      return instance.getArgsCount();
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @param index The index of the element to return.
     * @return The args at the given index.
     */
    @java.lang.Override
    public java.lang.String getArgs(int index) {
      return instance.getArgs(index);
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the args at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getArgsBytes(int index) {
      return instance.getArgsBytes(index);
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @param index The index to set the value at.
     * @param value The args to set.
     * @return This builder for chaining.
     */
    public Builder setArgs(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setArgs(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @param value The args to add.
     * @return This builder for chaining.
     */
    public Builder addArgs(
        java.lang.String value) {
      copyOnWrite();
      instance.addArgs(value);
      return this;
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @param values The args to add.
     * @return This builder for chaining.
     */
    public Builder addAllArgs(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllArgs(values);
      return this;
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearArgs() {
      copyOnWrite();
      instance.clearArgs();
      return this;
    }
    /**
     * <pre>
     * A list of arguments that will be presented to the step when it is started.
     * If the image used to run the step's container has an entrypoint, the `args`
     * are used as arguments to that entrypoint. If the image does not define
     * an entrypoint, the first element in args is used as the entrypoint,
     * and the remainder will be used as arguments.
     * </pre>
     *
     * <code>repeated string args = 3;</code>
     * @param value The bytes of the args to add.
     * @return This builder for chaining.
     */
    public Builder addArgsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addArgsBytes(value);
      return this;
    }

    /**
     * <pre>
     * Working directory to use when running this step's container.
     * If this value is a relative path, it is relative to the build's working
     * directory. If this value is absolute, it may be outside the build's working
     * directory, in which case the contents of the path may not be persisted
     * across build step executions, unless a `volume` for that path is specified.
     * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
     * which specifies an absolute path, the `RepoSource` `dir` is ignored for
     * the step's execution.
     * </pre>
     *
     * <code>string dir = 4;</code>
     * @return The dir.
     */
    @java.lang.Override
    public java.lang.String getDir() {
      return instance.getDir();
    }
    /**
     * <pre>
     * Working directory to use when running this step's container.
     * If this value is a relative path, it is relative to the build's working
     * directory. If this value is absolute, it may be outside the build's working
     * directory, in which case the contents of the path may not be persisted
     * across build step executions, unless a `volume` for that path is specified.
     * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
     * which specifies an absolute path, the `RepoSource` `dir` is ignored for
     * the step's execution.
     * </pre>
     *
     * <code>string dir = 4;</code>
     * @return The bytes for dir.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDirBytes() {
      return instance.getDirBytes();
    }
    /**
     * <pre>
     * Working directory to use when running this step's container.
     * If this value is a relative path, it is relative to the build's working
     * directory. If this value is absolute, it may be outside the build's working
     * directory, in which case the contents of the path may not be persisted
     * across build step executions, unless a `volume` for that path is specified.
     * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
     * which specifies an absolute path, the `RepoSource` `dir` is ignored for
     * the step's execution.
     * </pre>
     *
     * <code>string dir = 4;</code>
     * @param value The dir to set.
     * @return This builder for chaining.
     */
    public Builder setDir(
        java.lang.String value) {
      copyOnWrite();
      instance.setDir(value);
      return this;
    }
    /**
     * <pre>
     * Working directory to use when running this step's container.
     * If this value is a relative path, it is relative to the build's working
     * directory. If this value is absolute, it may be outside the build's working
     * directory, in which case the contents of the path may not be persisted
     * across build step executions, unless a `volume` for that path is specified.
     * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
     * which specifies an absolute path, the `RepoSource` `dir` is ignored for
     * the step's execution.
     * </pre>
     *
     * <code>string dir = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearDir() {
      copyOnWrite();
      instance.clearDir();
      return this;
    }
    /**
     * <pre>
     * Working directory to use when running this step's container.
     * If this value is a relative path, it is relative to the build's working
     * directory. If this value is absolute, it may be outside the build's working
     * directory, in which case the contents of the path may not be persisted
     * across build step executions, unless a `volume` for that path is specified.
     * If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
     * which specifies an absolute path, the `RepoSource` `dir` is ignored for
     * the step's execution.
     * </pre>
     *
     * <code>string dir = 4;</code>
     * @param value The bytes for dir to set.
     * @return This builder for chaining.
     */
    public Builder setDirBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDirBytes(value);
      return this;
    }

    /**
     * <pre>
     * Unique identifier for this build step, used in `wait_for` to
     * reference this build step as a dependency.
     * </pre>
     *
     * <code>string id = 5;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      return instance.getId();
    }
    /**
     * <pre>
     * Unique identifier for this build step, used in `wait_for` to
     * reference this build step as a dependency.
     * </pre>
     *
     * <code>string id = 5;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      return instance.getIdBytes();
    }
    /**
     * <pre>
     * Unique identifier for this build step, used in `wait_for` to
     * reference this build step as a dependency.
     * </pre>
     *
     * <code>string id = 5;</code>
     * @param value The id to set.
     * @return This builder for chaining.
     */
    public Builder setId(
        java.lang.String value) {
      copyOnWrite();
      instance.setId(value);
      return this;
    }
    /**
     * <pre>
     * Unique identifier for this build step, used in `wait_for` to
     * reference this build step as a dependency.
     * </pre>
     *
     * <code>string id = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearId() {
      copyOnWrite();
      instance.clearId();
      return this;
    }
    /**
     * <pre>
     * Unique identifier for this build step, used in `wait_for` to
     * reference this build step as a dependency.
     * </pre>
     *
     * <code>string id = 5;</code>
     * @param value The bytes for id to set.
     * @return This builder for chaining.
     */
    public Builder setIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @return A list containing the waitFor.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getWaitForList() {
      return java.util.Collections.unmodifiableList(
          instance.getWaitForList());
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @return The count of waitFor.
     */
    @java.lang.Override
    public int getWaitForCount() {
      return instance.getWaitForCount();
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @param index The index of the element to return.
     * @return The waitFor at the given index.
     */
    @java.lang.Override
    public java.lang.String getWaitFor(int index) {
      return instance.getWaitFor(index);
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @param index The index of the value to return.
     * @return The bytes of the waitFor at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWaitForBytes(int index) {
      return instance.getWaitForBytes(index);
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @param index The index to set the value at.
     * @param value The waitFor to set.
     * @return This builder for chaining.
     */
    public Builder setWaitFor(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setWaitFor(index, value);
      return this;
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @param value The waitFor to add.
     * @return This builder for chaining.
     */
    public Builder addWaitFor(
        java.lang.String value) {
      copyOnWrite();
      instance.addWaitFor(value);
      return this;
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @param values The waitFor to add.
     * @return This builder for chaining.
     */
    public Builder addAllWaitFor(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllWaitFor(values);
      return this;
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearWaitFor() {
      copyOnWrite();
      instance.clearWaitFor();
      return this;
    }
    /**
     * <pre>
     * The ID(s) of the step(s) that this build step depends on.
     * This build step will not start until all the build steps in `wait_for`
     * have completed successfully. If `wait_for` is empty, this build step will
     * start when all previous build steps in the `Build.Steps` list have
     * completed successfully.
     * </pre>
     *
     * <code>repeated string wait_for = 6;</code>
     * @param value The bytes of the waitFor to add.
     * @return This builder for chaining.
     */
    public Builder addWaitForBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addWaitForBytes(value);
      return this;
    }

    /**
     * <pre>
     * Entrypoint to be used instead of the build step image's default entrypoint.
     * If unset, the image's default entrypoint is used.
     * </pre>
     *
     * <code>string entrypoint = 7;</code>
     * @return The entrypoint.
     */
    @java.lang.Override
    public java.lang.String getEntrypoint() {
      return instance.getEntrypoint();
    }
    /**
     * <pre>
     * Entrypoint to be used instead of the build step image's default entrypoint.
     * If unset, the image's default entrypoint is used.
     * </pre>
     *
     * <code>string entrypoint = 7;</code>
     * @return The bytes for entrypoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEntrypointBytes() {
      return instance.getEntrypointBytes();
    }
    /**
     * <pre>
     * Entrypoint to be used instead of the build step image's default entrypoint.
     * If unset, the image's default entrypoint is used.
     * </pre>
     *
     * <code>string entrypoint = 7;</code>
     * @param value The entrypoint to set.
     * @return This builder for chaining.
     */
    public Builder setEntrypoint(
        java.lang.String value) {
      copyOnWrite();
      instance.setEntrypoint(value);
      return this;
    }
    /**
     * <pre>
     * Entrypoint to be used instead of the build step image's default entrypoint.
     * If unset, the image's default entrypoint is used.
     * </pre>
     *
     * <code>string entrypoint = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearEntrypoint() {
      copyOnWrite();
      instance.clearEntrypoint();
      return this;
    }
    /**
     * <pre>
     * Entrypoint to be used instead of the build step image's default entrypoint.
     * If unset, the image's default entrypoint is used.
     * </pre>
     *
     * <code>string entrypoint = 7;</code>
     * @param value The bytes for entrypoint to set.
     * @return This builder for chaining.
     */
    public Builder setEntrypointBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEntrypointBytes(value);
      return this;
    }

    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @return A list containing the secretEnv.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getSecretEnvList() {
      return java.util.Collections.unmodifiableList(
          instance.getSecretEnvList());
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @return The count of secretEnv.
     */
    @java.lang.Override
    public int getSecretEnvCount() {
      return instance.getSecretEnvCount();
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @param index The index of the element to return.
     * @return The secretEnv at the given index.
     */
    @java.lang.Override
    public java.lang.String getSecretEnv(int index) {
      return instance.getSecretEnv(index);
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the secretEnv at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSecretEnvBytes(int index) {
      return instance.getSecretEnvBytes(index);
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @param index The index to set the value at.
     * @param value The secretEnv to set.
     * @return This builder for chaining.
     */
    public Builder setSecretEnv(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setSecretEnv(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @param value The secretEnv to add.
     * @return This builder for chaining.
     */
    public Builder addSecretEnv(
        java.lang.String value) {
      copyOnWrite();
      instance.addSecretEnv(value);
      return this;
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @param values The secretEnv to add.
     * @return This builder for chaining.
     */
    public Builder addAllSecretEnv(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllSecretEnv(values);
      return this;
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearSecretEnv() {
      copyOnWrite();
      instance.clearSecretEnv();
      return this;
    }
    /**
     * <pre>
     * A list of environment variables which are encrypted using a Cloud Key
     * Management Service crypto key. These values must be specified in the
     * build's `Secret`.
     * </pre>
     *
     * <code>repeated string secret_env = 8;</code>
     * @param value The bytes of the secretEnv to add.
     * @return This builder for chaining.
     */
    public Builder addSecretEnvBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addSecretEnvBytes(value);
      return this;
    }

    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    @java.lang.Override
    public java.util.List<google.events.cloud.cloudbuild.v1.Volume> getVolumesList() {
      return java.util.Collections.unmodifiableList(
          instance.getVolumesList());
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    @java.lang.Override
    public int getVolumesCount() {
      return instance.getVolumesCount();
    }/**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    @java.lang.Override
    public google.events.cloud.cloudbuild.v1.Volume getVolumes(int index) {
      return instance.getVolumes(index);
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder setVolumes(
        int index, google.events.cloud.cloudbuild.v1.Volume value) {
      copyOnWrite();
      instance.setVolumes(index, value);
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder setVolumes(
        int index, google.events.cloud.cloudbuild.v1.Volume.Builder builderForValue) {
      copyOnWrite();
      instance.setVolumes(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder addVolumes(google.events.cloud.cloudbuild.v1.Volume value) {
      copyOnWrite();
      instance.addVolumes(value);
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder addVolumes(
        int index, google.events.cloud.cloudbuild.v1.Volume value) {
      copyOnWrite();
      instance.addVolumes(index, value);
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder addVolumes(
        google.events.cloud.cloudbuild.v1.Volume.Builder builderForValue) {
      copyOnWrite();
      instance.addVolumes(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder addVolumes(
        int index, google.events.cloud.cloudbuild.v1.Volume.Builder builderForValue) {
      copyOnWrite();
      instance.addVolumes(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder addAllVolumes(
        java.lang.Iterable<? extends google.events.cloud.cloudbuild.v1.Volume> values) {
      copyOnWrite();
      instance.addAllVolumes(values);
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder clearVolumes() {
      copyOnWrite();
      instance.clearVolumes();
      return this;
    }
    /**
     * <pre>
     * List of volumes to mount into the build step.
     * Each volume is created as an empty volume prior to execution of the
     * build step. Upon completion of the build, volumes and their contents are
     * discarded.
     * Using a named volume in only one step is not valid as it is indicative
     * of a build request with an incorrect configuration.
     * </pre>
     *
     * <code>repeated .google.events.cloud.cloudbuild.v1.Volume volumes = 9;</code>
     */
    public Builder removeVolumes(int index) {
      copyOnWrite();
      instance.removeVolumes(index);
      return this;
    }

    /**
     * <pre>
     * Stores timing information for executing this build step.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
     */
    @java.lang.Override
    public boolean hasTiming() {
      return instance.hasTiming();
    }
    /**
     * <pre>
     * Stores timing information for executing this build step.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
     */
    @java.lang.Override
    public google.events.cloud.cloudbuild.v1.TimeSpan getTiming() {
      return instance.getTiming();
    }
    /**
     * <pre>
     * Stores timing information for executing this build step.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
     */
    public Builder setTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
      copyOnWrite();
      instance.setTiming(value);
      return this;
      }
    /**
     * <pre>
     * Stores timing information for executing this build step.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
     */
    public Builder setTiming(
        google.events.cloud.cloudbuild.v1.TimeSpan.Builder builderForValue) {
      copyOnWrite();
      instance.setTiming(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Stores timing information for executing this build step.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
     */
    public Builder mergeTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
      copyOnWrite();
      instance.mergeTiming(value);
      return this;
    }
    /**
     * <pre>
     * Stores timing information for executing this build step.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan timing = 10;</code>
     */
    public Builder clearTiming() {  copyOnWrite();
      instance.clearTiming();
      return this;
    }

    /**
     * <pre>
     * Stores timing information for pulling this build step's
     * builder image only.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
     */
    @java.lang.Override
    public boolean hasPullTiming() {
      return instance.hasPullTiming();
    }
    /**
     * <pre>
     * Stores timing information for pulling this build step's
     * builder image only.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
     */
    @java.lang.Override
    public google.events.cloud.cloudbuild.v1.TimeSpan getPullTiming() {
      return instance.getPullTiming();
    }
    /**
     * <pre>
     * Stores timing information for pulling this build step's
     * builder image only.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
     */
    public Builder setPullTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
      copyOnWrite();
      instance.setPullTiming(value);
      return this;
      }
    /**
     * <pre>
     * Stores timing information for pulling this build step's
     * builder image only.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
     */
    public Builder setPullTiming(
        google.events.cloud.cloudbuild.v1.TimeSpan.Builder builderForValue) {
      copyOnWrite();
      instance.setPullTiming(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Stores timing information for pulling this build step's
     * builder image only.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
     */
    public Builder mergePullTiming(google.events.cloud.cloudbuild.v1.TimeSpan value) {
      copyOnWrite();
      instance.mergePullTiming(value);
      return this;
    }
    /**
     * <pre>
     * Stores timing information for pulling this build step's
     * builder image only.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.TimeSpan pull_timing = 13;</code>
     */
    public Builder clearPullTiming() {  copyOnWrite();
      instance.clearPullTiming();
      return this;
    }

    /**
     * <pre>
     * Time limit for executing this build step. If not defined, the step has no
     * time limit and will be allowed to continue to run until either it completes
     * or the build itself times out.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 11;</code>
     */
    @java.lang.Override
    public boolean hasTimeout() {
      return instance.hasTimeout();
    }
    /**
     * <pre>
     * Time limit for executing this build step. If not defined, the step has no
     * time limit and will be allowed to continue to run until either it completes
     * or the build itself times out.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 11;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Duration getTimeout() {
      return instance.getTimeout();
    }
    /**
     * <pre>
     * Time limit for executing this build step. If not defined, the step has no
     * time limit and will be allowed to continue to run until either it completes
     * or the build itself times out.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 11;</code>
     */
    public Builder setTimeout(com.google.protobuf.Duration value) {
      copyOnWrite();
      instance.setTimeout(value);
      return this;
      }
    /**
     * <pre>
     * Time limit for executing this build step. If not defined, the step has no
     * time limit and will be allowed to continue to run until either it completes
     * or the build itself times out.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 11;</code>
     */
    public Builder setTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      copyOnWrite();
      instance.setTimeout(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Time limit for executing this build step. If not defined, the step has no
     * time limit and will be allowed to continue to run until either it completes
     * or the build itself times out.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 11;</code>
     */
    public Builder mergeTimeout(com.google.protobuf.Duration value) {
      copyOnWrite();
      instance.mergeTimeout(value);
      return this;
    }
    /**
     * <pre>
     * Time limit for executing this build step. If not defined, the step has no
     * time limit and will be allowed to continue to run until either it completes
     * or the build itself times out.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 11;</code>
     */
    public Builder clearTimeout() {  copyOnWrite();
      instance.clearTimeout();
      return this;
    }

    /**
     * <pre>
     * Status of the build step. At this time, build step status is
     * only updated on build completion; step status is not updated in real-time
     * as the build progresses.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override
    public int getStatusValue() {
      return instance.getStatusValue();
    }
    /**
     * <pre>
     * Status of the build step. At this time, build step status is
     * only updated on build completion; step status is not updated in real-time
     * as the build progresses.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
     * @param value The status to set.
     * @return This builder for chaining.
     */
    public Builder setStatusValue(int value) {
      copyOnWrite();
      instance.setStatusValue(value);
      return this;
    }
    /**
     * <pre>
     * Status of the build step. At this time, build step status is
     * only updated on build completion; step status is not updated in real-time
     * as the build progresses.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
     * @return The status.
     */
    @java.lang.Override
    public google.events.cloud.cloudbuild.v1.BuildEventData.Status getStatus() {
      return instance.getStatus();
    }
    /**
     * <pre>
     * Status of the build step. At this time, build step status is
     * only updated on build completion; step status is not updated in real-time
     * as the build progresses.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
     * @param value The enum numeric value on the wire for status to set.
     * @return This builder for chaining.
     */
    public Builder setStatus(google.events.cloud.cloudbuild.v1.BuildEventData.Status value) {
      copyOnWrite();
      instance.setStatus(value);
      return this;
    }
    /**
     * <pre>
     * Status of the build step. At this time, build step status is
     * only updated on build completion; step status is not updated in real-time
     * as the build progresses.
     * </pre>
     *
     * <code>.google.events.cloud.cloudbuild.v1.BuildEventData.Status status = 12;</code>
     * @return This builder for chaining.
     */
    public Builder clearStatus() {
      copyOnWrite();
      instance.clearStatus();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.events.cloud.cloudbuild.v1.BuildStep)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new google.events.cloud.cloudbuild.v1.BuildStep();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "name_",
            "env_",
            "args_",
            "dir_",
            "id_",
            "waitFor_",
            "entrypoint_",
            "secretEnv_",
            "volumes_",
            google.events.cloud.cloudbuild.v1.Volume.class,
            "timing_",
            "timeout_",
            "status_",
            "pullTiming_",
          };
          java.lang.String info =
              "\u0000\r\u0000\u0000\u0001\r\r\u0000\u0005\u0000\u0001\u0208\u0002\u021a\u0003\u021a" +
              "\u0004\u0208\u0005\u0208\u0006\u021a\u0007\u0208\b\u021a\t\u001b\n\t\u000b\t\f\f" +
              "\r\t";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<google.events.cloud.cloudbuild.v1.BuildStep> parser = PARSER;
        if (parser == null) {
          synchronized (google.events.cloud.cloudbuild.v1.BuildStep.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<google.events.cloud.cloudbuild.v1.BuildStep>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.events.cloud.cloudbuild.v1.BuildStep)
  private static final google.events.cloud.cloudbuild.v1.BuildStep DEFAULT_INSTANCE;
  static {
    BuildStep defaultInstance = new BuildStep();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      BuildStep.class, defaultInstance);
  }

  public static google.events.cloud.cloudbuild.v1.BuildStep getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<BuildStep> PARSER;

  public static com.google.protobuf.Parser<BuildStep> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

